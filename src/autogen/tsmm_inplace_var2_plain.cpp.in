/*!GHOST_AUTOGEN_TSMM-INPLACE *,* */
#include "ghost/config.h"
#include "ghost/types.h"
#include "ghost/math.h"
#include "ghost/instr.h"
#include "ghost/util.h"
#include "ghost/tsmm_inplace_var2_plain_gen.h"
#include <complex>
#include <typeinfo>
#include <vector>

namespace {
template<typename T, typename iT>
ghost_error tsmm_inplace(ghost_densemat *x, ghost_densemat *w, void *alpha, void *beta)
{

    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH)
    ghost_error ret = GHOST_SUCCESS;

    ghost_lidx N = w->traits.ncols;
    ghost_lidx M = DM_NROWS(w);
    ghost_lidx K = DM_NROWS(x);

    GHOST_INFO_LOG("In inplace TSMM with arbitrary block sizes %dx%d <- %dx%d * %dx%d, %s %s",
         M, K, M, N, N, K, typeid(T).name(), typeid(iT).name());
    

    const iT *const __restrict__ wval = (iT *)w->val;
    T *const __restrict__ xval = (T *)x->val;

    const ghost_lidx ldw = w->stride;
    const ghost_lidx ldx = x->stride;

    iT dalpha = *(iT *)alpha;
    iT dbeta = *(iT *)beta;


    if ( M == 1 && N == 1) {
#pragma omp parallel for
      #pragma simd
      for (ghost_gidx k = 0; k < K; k++) {
        xval[k*ldx] = (T) ( xval[k*ldx] * dbeta +  wval[0] * xval[k*ldx] * dalpha);
      }
      GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH)
        return ret;
    }


    iT* tempw = (iT*) malloc(M*N*sizeof(iT));
    for( int m = 0; m < M; m++) {
      for( int n = 0; n < N; n++) {
        tempw[m*N + n] = wval[n*ldw + m];
      }
    }

#pragma omp parallel
    {
      T* temp = (T*) malloc(M*sizeof(T));
#pragma omp for
      for (ghost_gidx k = 0; k < K; k++) {
        memcpy(temp, xval + k*ldx, sizeof(T) * M);
#pragma omp simd
        for (ghost_lidx n = 0; n < N; n++) {
          iT sum = 0;
          for (ghost_lidx m = 0; m < M; m++) {
            sum += temp[m] * tempw[m*N + n];
          }
          xval[k*ldx + n] = (T) ( xval[k*ldx + n] * dbeta + sum * dalpha);
        }
      }
      free(temp);
    }
    free(tempw);
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH)
    return ret;
}
}


ghost_error ghost_tsmm_inplace__u_plain_x_x_x(ghost_densemat *x, ghost_densemat *w, void *alpha, void *beta)
{

    if (x->traits.datatype & GHOST_DT_REAL) {
        if (x->traits.datatype & GHOST_DT_DOUBLE && w->traits.datatype & GHOST_DT_DOUBLE) {
            return tsmm_inplace<double, double>(x, w, alpha, beta);
        } else if (x->traits.datatype & GHOST_DT_FLOAT && w->traits.datatype & GHOST_DT_FLOAT) {
            return tsmm_inplace<float, float>(x, w, alpha, beta);
        } else if (x->traits.datatype & GHOST_DT_FLOAT && w->traits.datatype & GHOST_DT_DOUBLE) {
            return tsmm_inplace<float, double>(x, w, alpha, beta);
        }
    } else if (x->traits.datatype & GHOST_DT_COMPLEX) {
        if (x->traits.datatype & GHOST_DT_DOUBLE) {
            return tsmm_inplace<std::complex<double>, std::complex<double>>(x, w, alpha, beta);
        } else if (x->traits.datatype & GHOST_DT_FLOAT) {
            return tsmm_inplace<std::complex<float>, std::complex<float>>(x, w, alpha, beta);
        }
    }
    return GHOST_ERR_DATATYPE;
}
