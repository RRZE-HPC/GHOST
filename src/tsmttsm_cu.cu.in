/*!GHOST_AUTOGEN BLOCKDIM1;BLOCKDIM2 */
#include "ghost/config.h"
#include "ghost/types.h"
#include "ghost/util.h"
#include "ghost/densemat.h"
#include "ghost/tsmttsm_cu_gen.h"
#include "ghost/tsmttsm_cu_kernel.h"
#include "ghost/cu_complex.h"

#GHOST_SUBST CFGK ${BLOCKDIM1}
#GHOST_SUBST CFGM ${BLOCKDIM2}

ghost_error ghost_tsmttsm__u_cuda_x_CFGK_CFGM_1_rm(ghost_densemat *x, ghost_densemat *v, ghost_densemat *w, void *alpha, void *beta, int conjv)
{
  GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH | GHOST_FUNCTYPE_KERNEL);
  ghost_error ret = GHOST_SUCCESS;

  if (1 /*conjv*/) {
    if (x->traits.datatype & GHOST_DT_COMPLEX) {
      ret = GHOST_ERR_NOT_IMPLEMENTED;
      /*      if (x->traits.datatype & GHOST_DT_DOUBLE) {
        ghost_tsmttsm_cu_cm_rm<cuDoubleComplex, CFGM, CFGK, 1>(
            (cuDoubleComplex *)x->cu_val, (const cuDoubleComplex *)v->cu_val,
            (const cuDoubleComplex *)w->cu_val, *(cuDoubleComplex *)alpha,
            *(cuDoubleComplex *)beta, v->traits.nrows, x->stride, v->stride,
            w->stride);
      } else {
        ghost_tsmttsm_cu_cm_rm<cuFloatComplex, CFGM, CFGK, 1>(
            (cuFloatComplex *)x->cu_val, (const cuFloatComplex *)v->cu_val,
            (const cuFloatComplex *)w->cu_val, *(cuFloatComplex *)alpha,
            *(cuFloatComplex *)beta, v->traits.nrows, x->stride, v->stride,
            w->stride);
      }
    } else {
      if (x->traits.datatype & GHOST_DT_DOUBLE) {
        ghost_tsmttsm_cu_cm_rm<double, CFGM, CFGK, 1>(
            (double *)x->cu_val, (const double *)v->cu_val,
            (const double *)w->cu_val, *(double *)alpha, *(double *)beta,
            v->traits.nrows, x->stride, v->stride, w->stride);
      } else {
        ghost_tsmttsm_cu_cm_rm<float, CFGM, CFGK, 1><<<grid, block>>>(
            (float *)x->cu_val, (const float *)v->cu_val,
            (const float *)w->cu_val, *(float *)alpha, *(float *)beta,
            v->traits.nrows, x->stride, v->stride, w->stride);
      }
      }*/
    } else {
      if (x->traits.datatype & GHOST_DT_COMPLEX) {
        /*  if (x->traits.datatype & GHOST_DT_DOUBLE) {
          ghost_tsmttsm_cu_cm_rm<cuDoubleComplex, CFGM, CFGK, 0>(
              (cuDoubleComplex *)x->cu_val, (const cuDoubleComplex *)v->cu_val,
              (const cuDoubleComplex *)w->cu_val, *(cuDoubleComplex *)alpha,
              *(cuDoubleComplex *)beta, v->traits.nrows, x->stride, v->stride,
              w->stride);
        } else {
          ghost_tsmttsm_cu_cm_rm<cuFloatComplex, CFGM, CFGK, 0>(
              (cuFloatComplex *)x->cu_val, (const cuFloatComplex *)v->cu_val,
              (const cuFloatComplex *)w->cu_val, *(cuFloatComplex *)alpha,
              *(cuFloatComplex *)beta, v->traits.nrows, x->stride, v->stride,
              w->stride);
              }*/
        ret = GHOST_ERR_NOT_IMPLEMENTED;
      } else {
        if (x->traits.datatype & GHOST_DT_DOUBLE) {
          ghost_tsmttsm_cu_rm<double, CFGM, CFGK, 0>(
              (double *)x->cu_val, (const double *)v->cu_val,
              (const double *)w->cu_val, *(double *)alpha, *(double *)beta,
              v->traits.nrows, x->stride, v->stride, w->stride);
        } else {
          ghost_tsmttsm_cu_cm_rm<float, CFGM, CFGK, 0>(
              (float *)x->cu_val, (const float *)v->cu_val,
              (const float *)w->cu_val, *(float *)alpha, *(float *)beta,
              v->traits.nrows, x->stride, v->stride, w->stride);
        }
      }
    }
  }
  GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH | GHOST_FUNCTYPE_KERNEL);
  CUDA_CALL_RETURN(cudaGetLastError());
  return ret;
}
