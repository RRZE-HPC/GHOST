#include "ghost/config.h"
#include "ghost/types.h"
#include "ghost/math.h"
#include "ghost/instr.h"
#include "ghost/locality.h"
#include "ghost/util.h"
#include "ghost/tsmttsm_kahan_gen.h"


ghost_error_t ghost_tsmttsm_kahan__a_plain_d_x_x_cm_rm(ghost_densemat_t *x, ghost_densemat_t *v, ghost_densemat_t *w, void *alpha, void *beta, int conjv)
{
    UNUSED(conjv);
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH)
    ghost_error_t ret = GHOST_SUCCESS;
    ghost_lidx_t K = w->traits.ncols;
    ghost_lidx_t n = v->traits.nrows;
    ghost_lidx_t m = v->traits.ncols;
    double finalc[m*K];

    int myrank=0;

    if (v->context) {
        GHOST_CALL_GOTO(ghost_rank(&myrank,v->context->mpicomm),err,ret);
    }

    
    INFO_LOG("In TSMTTSM with arbitrary block sizes %dx%d <- %dx%d * %dx%d",m,K,m,n,n,K);
    
    const double * const restrict vval = (const double *) v->val;
    const double * const restrict wval = (const double *) w->val;
    double * const restrict xval = (double *) x->val;

    const ghost_lidx_t ldv = v->stride;
    const ghost_lidx_t ldw = w->stride;
    const ghost_lidx_t ldx = x->stride;
    
    double dalpha = *(double *)alpha;
    double dbeta = *(double *)beta;
    
    // make sure that the initial x only gets added up once
    if (myrank) {
        dbeta = 0.;
    }

    ghost_lidx_t i,j;
        
    memset(finalc,0,sizeof(finalc));
    
    if (x->traits.storage == GHOST_DENSEMAT_COLMAJOR) {
        ghost_lidx_t k;
        for (j=0; j<m; j++) {
            for (k=0; k<K; k++) {
                xval[k*ldx+j] = dbeta*xval[k*ldx+j];
            }
        }
#pragma omp parallel private(j,k) shared(finalc)
        {
            double *x_priv, *c, *y, *t;
            ghost_malloc((void **)&x_priv,m*K*sizeof(double));
            ghost_malloc((void **)&c,m*K*sizeof(double));
            ghost_malloc((void **)&y,m*K*sizeof(double));
            ghost_malloc((void **)&t,m*K*sizeof(double));
            memset(x_priv,0,m*K*sizeof(double));
            memset(c,0,m*K*sizeof(double));
#pragma omp for schedule(runtime)
            for (i=0; i<n; i++) {
#pragma vector aligned
#pragma ivdep
#pragma simd
                for (k=0; k<K; k++) {
#pragma unroll_and_jam
#pragma float_control(precise,on)
                  for (j=0; j<m; j++) {
                        y[j*K+k] = dalpha*vval[i*ldv+j]*wval[i*ldw+k] - c[j*K+k];
                        t[j*K+k] = x_priv[j*K+k] + y[j*K+k];
                        c[j*K+k] = (t[j*K+k] - x_priv[j*K+k]) - y[j*K+k];
                        x_priv[j*K+k] = t[j*K+k]; 
//                        x_priv[j*K+k] += dalpha*vval[i*ldv+j]*wval[i*ldw+k];
                    }
                }

            }
#pragma omp critical
            {
#pragma vector aligned
#pragma ivdep
#pragma simd
                for (k=0; k<K; k++) {
#pragma unroll_and_jam
#pragma float_control(precise,on)
                    for (j=0; j<m; j++) {
                        y[j*K+k] = x_priv[j*K+k] - finalc[j*K+k];
                        t[j*K+k] = xval[k*ldx+j] + y[j*K+k];
                        finalc[j*K+k] = (t[j*K+k] - xval[k*ldx+j]) - y[j*K+k];
                        xval[k*ldx+j] = t[j*K+k]; 
                        //xval[k*ldx+j] += x_priv[j*K+k];
                    }
                }
            }
            free(x_priv);
            free(c);
            free(y);
            free(t);
        }
    
    } else {
        ghost_lidx_t k;
        for (j=0; j<m; j++) {
            for (k=0; k<K; k++) {
                xval[j*ldx+k] = dbeta*xval[j*ldx+k];
            }
        }
#pragma omp parallel private(j,k)
        {
            double *x_priv;
            ghost_malloc((void **)&x_priv,m*K*sizeof(double));
            memset(x_priv,0,m*K*sizeof(double));
#pragma omp for schedule(runtime)
            for (i=0; i<n; i++) {
                for (j=0; j<m; j++) {
#pragma simd
#pragma vector always
#pragma vector aligned
#pragma ivdep
#pragma unroll
                    for (k=0; k<K; k++) {
                        x_priv[j*K+k] += dalpha*vval[i*ldv+j]*wval[i*ldw+k];
                    }
                }

            }
#pragma omp critical
            for (j=0; j<m; j++) {
#pragma simd
#pragma vector always
#pragma vector aligned
#pragma ivdep
#pragma unroll
                for (k=0; k<K; k++) {
                    xval[j*ldx+k] += x_priv[j*K+k];
                }
            }
            free(x_priv);
        }

    }
   
    goto out;
err:

out:
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH)
    return ret;
}

ghost_error_t ghost_tsmttsm_kahan__a_plain_z_x_x_cm_rm(ghost_densemat_t *x, ghost_densemat_t *v, ghost_densemat_t *w, void *alpha, void *beta, int conjv)
{
    UNUSED(conjv);
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH)
    ghost_error_t ret = GHOST_SUCCESS;
    ghost_lidx_t K = w->traits.ncols;
    ghost_lidx_t n = v->traits.nrows;
    ghost_lidx_t m = v->traits.ncols;
    complex double finalc[m*K];

    int myrank=0;

    if (v->context) {
        GHOST_CALL_GOTO(ghost_rank(&myrank,v->context->mpicomm),err,ret);
    }

    
    INFO_LOG("In TSMTTSM with arbitrary block sizes %dx%d <- %dx%d * %dx%d",m,K,m,n,n,K);
    
    const double complex * const restrict vval = (const double complex*) v->val;
    const double complex * const restrict wval = (const double complex*) w->val;
    double complex * const restrict xval = (double complex*) x->val;

    const ghost_lidx_t ldv = v->stride;
    const ghost_lidx_t ldw = w->stride;
    const ghost_lidx_t ldx = x->stride;
    
    const complex double dalpha = *(complex double *)alpha;
    complex double dbeta = *(complex double *)beta;
    
    ghost_mpi_op_t mpiop_zadd;
    ghost_mpi_datatype_t mpidt_z;
    ghost_mpi_op_sum(&mpiop_zadd,(ghost_datatype_t)(GHOST_DT_COMPLEX|GHOST_DT_DOUBLE));
    ghost_mpi_datatype(&mpidt_z,(ghost_datatype_t)(GHOST_DT_COMPLEX|GHOST_DT_DOUBLE));
    
    // make sure that the initial x only gets added up once
    if (myrank) {
        dbeta = 0.;
    }

    ghost_lidx_t i,j;
        
    memset(finalc,0,sizeof(finalc));
    
    if (x->traits.storage == GHOST_DENSEMAT_COLMAJOR) {
        ghost_lidx_t k;
        for (j=0; j<m; j++) {
            for (k=0; k<K; k++) {
                xval[k*ldx+j] = dbeta*xval[k*ldx+j];
            }
        }
#pragma omp parallel private(j,k) shared(finalc)
        {
            complex double *x_priv, *c, *y, *t;
            ghost_malloc((void **)&x_priv,m*K*sizeof(complex double));
            ghost_malloc((void **)&c,m*K*sizeof(complex double));
            ghost_malloc((void **)&y,m*K*sizeof(complex double));
            ghost_malloc((void **)&t,m*K*sizeof(complex double));
            memset(x_priv,0,m*K*sizeof(complex double));
            memset(c,0,m*K*sizeof(complex double));
            
            if (conjv) {
#pragma omp for schedule(runtime)
                for (i=0; i<n; i++) {
#pragma vector aligned
#pragma ivdep
#pragma simd
                    for (k=0; k<K; k++) {
#pragma unroll_and_jam
#pragma float_control(precise,on)
                      for (j=0; j<m; j++) {
                            y[j*K+k] = dalpha*conj(vval[i*ldv+j])*wval[i*ldw+k] - c[j*K+k];
                            t[j*K+k] = x_priv[j*K+k] + y[j*K+k];
                            c[j*K+k] = (t[j*K+k] - x_priv[j*K+k]) - y[j*K+k];
                            x_priv[j*K+k] = t[j*K+k]; 
    //                        x_priv[j*K+k] += dalpha*vval[i*ldv+j]*wval[i*ldw+k];
                        }
                    }

                }
            } else {
#pragma omp for schedule(runtime)
                for (i=0; i<n; i++) {
#pragma vector aligned
#pragma ivdep
#pragma simd
                    for (k=0; k<K; k++) {
#pragma unroll_and_jam
#pragma float_control(precise,on)
                      for (j=0; j<m; j++) {
                            y[j*K+k] = dalpha*vval[i*ldv+j]*wval[i*ldw+k] - c[j*K+k];
                            t[j*K+k] = x_priv[j*K+k] + y[j*K+k];
                            c[j*K+k] = (t[j*K+k] - x_priv[j*K+k]) - y[j*K+k];
                            x_priv[j*K+k] = t[j*K+k]; 
    //                        x_priv[j*K+k] += dalpha*vval[i*ldv+j]*wval[i*ldw+k];
                        }
                    }

                }
            }
#pragma omp critical
            {
#pragma vector aligned
#pragma ivdep
#pragma simd
                for (k=0; k<K; k++) {
#pragma unroll_and_jam
#pragma float_control(precise,on)
                    for (j=0; j<m; j++) {
                        y[j*K+k] = x_priv[j*K+k] - finalc[j*K+k];
                        t[j*K+k] = xval[k*ldx+j] + y[j*K+k];
                        finalc[j*K+k] = (t[j*K+k] - xval[k*ldx+j]) - y[j*K+k];
                        xval[k*ldx+j] = t[j*K+k]; 
                        //xval[k*ldx+j] += x_priv[j*K+k];
                    }
                }
            }
            free(x_priv);
            free(c);
            free(y);
            free(t);
        }
    
    } else {
        ghost_lidx_t k;
        for (j=0; j<m; j++) {
            for (k=0; k<K; k++) {
                xval[j*ldx+k] = dbeta*xval[j*ldx+k];
            }
        }
#pragma omp parallel private(j,k)
        {
            complex double *x_priv;
            ghost_malloc((void **)&x_priv,m*K*sizeof(complex double));
            memset(x_priv,0,m*K*sizeof(complex double));
            
            if (conjv) {
#pragma omp for schedule(runtime)
                for (i=0; i<n; i++) {
                    for (j=0; j<m; j++) {
#pragma simd
#pragma vector always
#pragma vector aligned
#pragma ivdep
#pragma unroll
                        for (k=0; k<K; k++) {
                            x_priv[j*K+k] += dalpha*conj(vval[i*ldv+j])*wval[i*ldw+k];
                        }
                    }

                }
            } else {
#pragma omp for schedule(runtime)
                for (i=0; i<n; i++) {
                    for (j=0; j<m; j++) {
#pragma simd
#pragma vector always
#pragma vector aligned
#pragma ivdep
#pragma unroll
                        for (k=0; k<K; k++) {
                            x_priv[j*K+k] += dalpha*vval[i*ldv+j]*wval[i*ldw+k];
                        }
                    }

                }
            }
#pragma omp critical
            for (j=0; j<m; j++) {
#pragma simd
#pragma vector always
#pragma vector aligned
#pragma ivdep
#pragma unroll
                for (k=0; k<K; k++) {
                    xval[j*ldx+k] += x_priv[j*K+k];
                }
            }
            free(x_priv);
        }

    }
   
    goto out;
err:

out:
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH)
    return ret;
}

#GHOST_FUNC_BEGIN#CFGK=${CFG_BLOCKVECTOR_SIZES}#CFGM=${CFG_BLOCKVECTOR_SIZES}
ghost_error_t ghost_tsmttsm_kahan__a_plain_d_CFGK_CFGM_cm_rm(ghost_densemat_t *x, ghost_densemat_t *v, ghost_densemat_t *w, void *alpha, void *beta, int conjv)
{
    UNUSED(conjv);
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH)
    ghost_error_t ret = GHOST_SUCCESS;

    int myrank=0;

    if (v->context) {
        GHOST_CALL_GOTO(ghost_rank(&myrank,v->context->mpicomm),err,ret);
    }

    ghost_lidx_t n = v->traits.nrows;
    INFO_LOG("In TSMTTSM with two fixed block sizes %dx%d <- %dx%d * %dx%d",CFGM,CFGK,CFGM,n,n,CFGK);
    
    const double * const restrict vval = (const double *) v->val;
    const double * const restrict wval = (const double *) w->val;
    double * const restrict xval = (double *) x->val;

    const ghost_lidx_t ldv = v->stride;
    const ghost_lidx_t ldw = w->stride;
    const ghost_lidx_t ldx = x->stride;
    
    double dalpha = *(double *)alpha;
    double dbeta = *(double *)beta;
    
    // make sure that the initial x only gets added up once
    if (myrank) {
        dbeta = 0.;
    }

    ghost_lidx_t i,j;
    
    if (x->traits.storage == GHOST_DENSEMAT_COLMAJOR) {
        ghost_lidx_t k;
#if CFGK>1
#pragma simd
#endif
        for (k=0; k<CFGK; k++) {
            for (j=0; j<CFGM; j++) {
                xval[k*ldx+j] = dbeta*xval[k*ldx+j];
            }
        }
            
        double finalc[CFGM*CFGK];
        memset(finalc,0,sizeof(finalc));


#pragma omp parallel private(j,k) shared(finalc)
        {
            double *x_priv, *c, *y, *t;
            ghost_malloc((void **)&x_priv,CFGM*CFGK*sizeof(double));
            ghost_malloc((void **)&c,CFGM*CFGK*sizeof(double));
            ghost_malloc((void **)&y,CFGM*CFGK*sizeof(double));
            ghost_malloc((void **)&t,CFGM*CFGK*sizeof(double));
            memset(x_priv,0,CFGM*CFGK*sizeof(double));
            memset(c,0,CFGM*CFGK*sizeof(double));

#pragma omp for schedule(runtime)
            for (i=0; i<n-3; i+=4) {
                for (k=0; k<CFGK; k++) {
#pragma simd
                  for (j=0; j<CFGM; j++) {
                        y[j*CFGK+k] = dalpha*(vval[i*ldv+j]*wval[i*ldw+k]+vval[(i+1)*ldv+j]*wval[(i+1)*ldw+k]+vval[(i+2)*ldv+j]*wval[(i+2)*ldw+k]+vval[(i+3)*ldv+j]*wval[(i+3)*ldw+k]) - c[j*CFGK+k];
                        t[j*CFGK+k] = x_priv[j*CFGK+k] + y[j*CFGK+k];
                        c[j*CFGK+k] = (t[j*CFGK+k] - x_priv[j*CFGK+k]) - y[j*CFGK+k];
                        x_priv[j*CFGK+k] = t[j*CFGK+k]; 
                    }
                }

            }
#pragma omp critical
            for (k=0; k<CFGK; k++) {
#pragma simd
                for (j=0; j<CFGM; j++) {
                    y[j*CFGK+k] = x_priv[j*CFGK+k] - finalc[j*CFGK+k];
                    t[j*CFGK+k] = xval[k*ldx+j] + y[j*CFGK+k];
                    finalc[j*CFGK+k] = (t[j*CFGK+k] - xval[k*ldx+j]) - y[j*CFGK+k];
                    xval[k*ldx+j] = t[j*CFGK+k];
                }
            }
            free(x_priv);
            free(c);
            free(y);
            free(t);
        }
    } else {
        ERROR_LOG("Will be implemented soon :-)!");
        ret = GHOST_ERR_NOT_IMPLEMENTED;
        goto err;
    }
   
    goto out;
err:

out:
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH)
    return ret;
}
#GHOST_FUNC_END

#GHOST_FUNC_BEGIN#CFGK=${CFG_BLOCKVECTOR_SIZES}#CFGM=${CFG_BLOCKVECTOR_SIZES}
ghost_error_t ghost_tsmttsm_kahan__a_plain_z_CFGK_CFGM_cm_rm(ghost_densemat_t *x, ghost_densemat_t *v, ghost_densemat_t *w, void *alpha, void *beta, int conjv)
{
    UNUSED(conjv);
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH)
    ghost_error_t ret = GHOST_SUCCESS;

    int myrank=0;

    if (v->context) {
        GHOST_CALL_GOTO(ghost_rank(&myrank,v->context->mpicomm),err,ret);
    }

    ghost_lidx_t n = v->traits.nrows;
    INFO_LOG("In TSMTTSM with two fixed block sizes %dx%d <- %dx%d * %dx%d",CFGM,CFGK,CFGM,n,n,CFGK);
    
    const double complex * const restrict vval = (const double complex*) v->val;
    const double complex * const restrict wval = (const double complex*) w->val;
    double complex * const restrict xval = (double complex*) x->val;

    const ghost_lidx_t ldv = v->stride;
    const ghost_lidx_t ldw = w->stride;
    const ghost_lidx_t ldx = x->stride;
    
    const complex double dalpha = *(complex double *)alpha;
    complex double dbeta = *(complex double *)beta;
    
    ghost_mpi_op_t mpiop_zadd;
    ghost_mpi_datatype_t mpidt_z;
    ghost_mpi_op_sum(&mpiop_zadd,(ghost_datatype_t)(GHOST_DT_COMPLEX|GHOST_DT_DOUBLE));
    ghost_mpi_datatype(&mpidt_z,(ghost_datatype_t)(GHOST_DT_COMPLEX|GHOST_DT_DOUBLE));
    
    // make sure that the initial x only gets added up once
    if (myrank) {
        dbeta = 0.;
    }

    ghost_lidx_t i,j;
    
    if (x->traits.storage == GHOST_DENSEMAT_COLMAJOR) {
        ghost_lidx_t k;
#if CFGK>2
#pragma simd
#endif
        for (k=0; k<CFGK; k++) {
            for (j=0; j<CFGM; j++) {
                xval[k*ldx+j] = dbeta*xval[k*ldx+j];
            }
        }
            
        complex double finalc[CFGM*CFGK];
        memset(finalc,0,sizeof(finalc));


#pragma omp parallel private(j,k) shared(finalc)
        {
            complex double *x_priv, *c, *y, *t;

            ghost_malloc((void **)&x_priv,CFGM*CFGK*sizeof(complex double));
            ghost_malloc((void **)&c,CFGM*CFGK*sizeof(complex double));
            ghost_malloc((void **)&y,CFGM*CFGK*sizeof(complex double));
            ghost_malloc((void **)&t,CFGM*CFGK*sizeof(complex double));

            memset(x_priv,0,CFGM*CFGK*sizeof(complex double));
            memset(c,0,CFGM*CFGK*sizeof(complex double));

            if (conjv) {

#pragma omp for schedule(runtime)
                for (i=0; i<n; i++) {
#if CFGK>2
#pragma simd
#pragma vector aligned
#pragma ivdep
#endif
                    for (k=0; k<CFGK; k++) {
#pragma float_control(precise,on)
#pragma unroll_and_jam
                      for (j=0; j<CFGM; j++) {
                            y[j*CFGK+k] = dalpha*conj(vval[i*ldv+j])*wval[i*ldw+k] - c[j*CFGK+k];
                            t[j*CFGK+k] = x_priv[j*CFGK+k] + y[j*CFGK+k];
                            c[j*CFGK+k] = (t[j*CFGK+k] - x_priv[j*CFGK+k]) - y[j*CFGK+k];
                            x_priv[j*CFGK+k] = t[j*CFGK+k]; 
                            //x_priv[j*CFGK+k] += dalpha*vval[i*ldv+j]*wval[i*ldw+k];
                        }
                    }

                }

            } else {
                
                for (i=0; i<n; i++) {
#if CFGK>2
#pragma simd
#pragma vector aligned
#pragma ivdep
#endif
                    for (k=0; k<CFGK; k++) {
#pragma float_control(precise,on)
#pragma unroll_and_jam
                      for (j=0; j<CFGM; j++) {
                            y[j*CFGK+k] = dalpha*vval[i*ldv+j]*wval[i*ldw+k] - c[j*CFGK+k];
                            t[j*CFGK+k] = x_priv[j*CFGK+k] + y[j*CFGK+k];
                            c[j*CFGK+k] = (t[j*CFGK+k] - x_priv[j*CFGK+k]) - y[j*CFGK+k];
                            x_priv[j*CFGK+k] = t[j*CFGK+k]; 
                            //x_priv[j*CFGK+k] += dalpha*vval[i*ldv+j]*wval[i*ldw+k];
                        }
                    }

                }
            }

#pragma omp critical
#if CFGK>2
#pragma simd
#pragma vector aligned
#pragma ivdep
#endif
            for (k=0; k<CFGK; k++) {
#pragma float_control(precise,on)
#pragma unroll_and_jam
                for (j=0; j<CFGM; j++) {
                    y[j*CFGK+k] = x_priv[j*CFGK+k] - finalc[j*CFGK+k];
                    t[j*CFGK+k] = xval[k*ldx+j] + y[j*CFGK+k];
                    finalc[j*CFGK+k] = (t[j*CFGK+k] - xval[k*ldx+j]) - y[j*CFGK+k];
                    xval[k*ldx+j] = t[j*CFGK+k];
                }
            }

            free(x_priv);
            free(c);
            free(y);
            free(t);
        }
    } else {
        ERROR_LOG("Will be implemented soon :-)!");
        ret = GHOST_ERR_NOT_IMPLEMENTED;
        goto err;
    }
   
    goto out;
err:

out:
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH)
    return ret;
}
#GHOST_FUNC_END
