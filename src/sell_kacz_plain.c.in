/*!GHOST_AUTOGEN CHUNKHEIGHT;BLOCKDIM1 */
#include "ghost/config.h"
#include "ghost/types.h"
#include "ghost/util.h"
#include "ghost/math.h"
#include "ghost/sell_kacz_plain_gen.h"

#GHOST_SUBST NVECS ${BLOCKDIM1}
#GHOST_SUBST CHUNKHEIGHT ${CHUNKHEIGHT}

ghost_error ghost_kacz__u_plain_d_d_cm_CHUNKHEIGHT_NVECS(ghost_densemat *x, ghost_sparsemat *mat, ghost_densemat *b, ghost_kacz_opts opts)
{
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH|GHOST_FUNCTYPE_KERNEL);
    
    if (!mat->color_ptr || mat->ncolors == 0) {
        WARNING_LOG("Matrix has not been colored!");
    }

    if (NVECS > 1) {
        ERROR_LOG("Multi-vec not implemented!");
        return GHOST_ERR_NOT_IMPLEMENTED;
    }
   
    ghost_lidx c;
    ghost_lidx row;
    ghost_lidx rowinchunk;
    ghost_lidx j;
    ghost_lidx color;
    ghost_sell *sellmat = SELL(mat);
    ghost_lidx fchunk, lchunk;
    double *bval = (double *)(b->val);
    double *xval = (double *)(x->val);
    double *mval = (double *)sellmat->val;
    double omega = *(double *)opts.omega;

    ghost_lidx firstcolor, lastcolor, stride;
    
    if (opts.direction == GHOST_KACZ_DIRECTION_FORWARD) {
        firstcolor = 0;
        lastcolor = mat->ncolors;
        stride = 1;
    } else {
        firstcolor = mat->ncolors-1;
        lastcolor = -1;
        stride = -1;
    }

    
    for (color=firstcolor; color!=lastcolor; color+=stride) {
        fchunk = mat->color_ptr[color]/CHUNKHEIGHT;
        lchunk = mat->color_ptr[color+1]/CHUNKHEIGHT;
#pragma omp parallel
        { 
            double *rownorm;
            ghost_malloc((void **)&rownorm,CHUNKHEIGHT*sizeof(double));
#pragma omp for private(j,row,rowinchunk)
            for (c=fchunk; c<lchunk; c++) {
                for (rowinchunk = 0; rowinchunk < CHUNKHEIGHT; rowinchunk++) {
                    row = rowinchunk + c*CHUNKHEIGHT;
                    rownorm[rowinchunk] = 0.;

                    ghost_lidx idx = sellmat->chunkStart[c]+rowinchunk;
                    double scal = -bval[row];

                    for (j=0; j<sellmat->rowLen[row]; j++) {
                        scal += (double)mval[idx] * xval[sellmat->col[idx]];
                        rownorm[rowinchunk] += mval[idx]*mval[idx];
                        idx += CHUNKHEIGHT;
                    }

                    idx -= CHUNKHEIGHT*sellmat->rowLen[row];
                    scal /= (double)rownorm[rowinchunk];

                    for (j=0; j<sellmat->rowLen[row]; j++) {
                        xval[sellmat->col[idx]] = xval[sellmat->col[idx]] - omega * scal * (double)mval[idx];
                        idx += CHUNKHEIGHT;
                    }
                }
            }
            free(rownorm);
            rownorm = NULL;
        }
    }
    
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH|GHOST_FUNCTYPE_KERNEL);
    return GHOST_SUCCESS;
}


