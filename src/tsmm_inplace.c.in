#include "ghost/config.h"
#include "ghost/types.h"
#include "ghost/math.h"
#include "ghost/instr.h"
#include "ghost/util.h"

#GHOST_FUNC_BEGIN#BLOCKSZ=${CFG_BLOCKVECTOR_SIZES}
ghost_error_t ghost_tsmm_inplace__plain_d_BLOCKSZ(ghost_densemat_t *x, ghost_densemat_t *w, void *alpha)
{
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH)
    ghost_error_t ret = GHOST_SUCCESS;

    ghost_lidx_t m = x->traits.ncols;
    ghost_lidx_t n = x->traits.nrows;

    double dalpha = *(double *)alpha;
    
    INFO_LOG("In in-place TSMM with fixed block size [BLOCKSZ] (%"PRLIDX"x%"PRLIDX") <- %f * (%"PRLIDX"x%"PRLIDX") * (%"PRLIDX"x%"PRLIDX")",n,m,dalpha,n,m,m,m);

    double * restrict wval, * restrict xval;
    ghost_lidx_t ldw, ldx;

    ldw = *w->stride;
    ldx = *x->stride;

    ghost_densemat_valptr(w,(void **)&wval);
    ghost_densemat_valptr(x,(void **)&xval);

    double tmp[BLOCKSZ];
    ghost_lidx_t i,j,s;

#pragma omp parallel for private(j,s,tmp) schedule(runtime)
    for (i=0; i<n; i++) {
        memset(tmp,0,BLOCKSZ*sizeof(double));
#pragma simd
        for (s=0; s<BLOCKSZ; s++) {
            for (j=0; j<BLOCKSZ; j++) {
                tmp[s] += dalpha*xval[i*ldx+j]*wval[s*ldw+j];
            }
        }
        memcpy(&xval[i*ldx],tmp,BLOCKSZ*sizeof(double));
    }
    
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH)
    return ret;
}
#GHOST_FUNC_END

ghost_error_t ghost_tsmm_inplace__plain_d_x(ghost_densemat_t *x, ghost_densemat_t *w, void *alpha)
{
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH)
    ghost_error_t ret = GHOST_SUCCESS;

    ghost_lidx_t m = x->traits.ncols;
    ghost_lidx_t n = x->traits.nrows;

    double dalpha = *(double *)alpha;
    
    INFO_LOG("In in-place TSMM with arbitrary block size (%"PRLIDX"x%"PRLIDX") <- %f * (%"PRLIDX"x%"PRLIDX") * (%"PRLIDX"x%"PRLIDX")",n,m,dalpha,n,m,m,m);

    double * restrict wval, * restrict xval;
    ghost_lidx_t ldw, ldx;

    ldw = *w->stride;
    ldx = *x->stride;

    ghost_densemat_valptr(w,(void **)&wval);
    ghost_densemat_valptr(x,(void **)&xval);

    double tmp[x->traits.ncols];
    ghost_lidx_t i,j,s;

#pragma omp parallel for private(j,s,tmp) schedule(runtime)
    for (i=0; i<n; i++) {
        memset(tmp,0,x->traits.ncols*sizeof(double));
#pragma simd
        for (s=0; s<x->traits.ncols; s++) {
            for (j=0; j<x->traits.ncols; j++) {
                tmp[s] += dalpha*xval[i*ldx+j]*wval[s*ldw+j];
            }
        }
        memcpy(&xval[i*ldx],tmp,x->traits.ncols*sizeof(double));
    }
    
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH)
    return ret;
}

ghost_error_t ghost_tsmm_inplace__plain_z_x(ghost_densemat_t *x, ghost_densemat_t *w, void *alpha)
{
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH)
    ghost_error_t ret = GHOST_SUCCESS;

    ghost_lidx_t m = x->traits.ncols;
    ghost_lidx_t n = x->traits.nrows;

    double complex dalpha = *(double complex *)alpha;
    
    INFO_LOG("In in-place TSMM with arbitrary block size (%"PRLIDX"x%"PRLIDX") <- %f+I*%f * (%"PRLIDX"x%"PRLIDX") * (%"PRLIDX"x%"PRLIDX")",n,m,creal(dalpha),cimag(dalpha),n,m,m,m);

    double complex * restrict wval, * restrict xval;
    ghost_lidx_t ldw, ldx;

    ldw = *w->stride;
    ldx = *x->stride;

    ghost_densemat_valptr(w,(void **)&wval);
    ghost_densemat_valptr(x,(void **)&xval);

    double complex tmp[x->traits.ncols];
    ghost_lidx_t i,j,s;

#pragma omp parallel for private(j,s,tmp) schedule(runtime)
    for (i=0; i<n; i++) {
        memset(tmp,0,x->traits.ncols*sizeof(double complex));
#pragma simd
        for (s=0; s<x->traits.ncols; s++) {
            for (j=0; j<x->traits.ncols; j++) {
                tmp[s] += dalpha*xval[i*ldx+j]*wval[s*ldw+j];
            }
        }
        memcpy(&xval[i*ldx],tmp,x->traits.ncols*sizeof(double complex));
    }
    
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH)
    return ret;
}

