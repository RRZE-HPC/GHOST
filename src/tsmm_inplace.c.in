#include "ghost/config.h"
#include "ghost/types.h"
#include "ghost/math.h"
#include "ghost/instr.h"
#include "ghost/util.h"
#include "ghost/tsmm_inplace_gen.h"

#GHOST_FUNC_BEGIN#NCOLSIN=${CFG_BLOCKVECTOR_SIZES}#NCOLSOUT=${CFG_BLOCKVECTOR_SIZES}
ghost_error_t ghost_tsmm_inplace__plain_d_NCOLSIN_NCOLSOUT(ghost_densemat_t *x, ghost_densemat_t *w, void *alpha, void *beta)
{
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH)
    ghost_error_t ret = GHOST_SUCCESS;

    ghost_lidx_t m = x->traits.ncols;
    ghost_lidx_t n = x->traits.nrows;

    double dalpha = *(double *)alpha;
    double dbeta = *(double *)beta;
    
    INFO_LOG("In in-place TSMM with fixed block sizes [NCOLSIN][NCOLSOUT] (%"PRLIDX"x%"PRLIDX") <- %f * (%"PRLIDX"x%"PRLIDX") * (%"PRLIDX"x%"PRLIDX")",n,NCOLSOUT,dalpha,n,m,w->traits.nrows,NCOLSOUT);

    double * restrict wval = NULL, * restrict xval;
    ghost_lidx_t ldw, ldx;

    ldw = w->stride;
    ldx = x->stride;

    ghost_densemat_valptr(w,(void **)&wval);
    ghost_densemat_valptr(x,(void **)&xval);

    ghost_lidx_t i,j,s;

    /* construct dense wval... we can safely copy it as it is small! */
    double * restrict wtmp = NULL;
    ghost_lidx_t ncolsin_padded = PAD(NCOLSIN,4);
    ghost_malloc_align((void**)&wtmp,ncolsin_padded*NCOLSOUT*sizeof(double),32);
    memset(wtmp,0,ncolsin_padded*NCOLSOUT*sizeof(double));
    for(s=0; s<NCOLSOUT; s++)
    {
      for(j=0; j<NCOLSIN; j++)
      {
        wtmp[s*ncolsin_padded+j] = dalpha*wval[s*ldw+j];
        if(s==j)
          wtmp[s*ncolsin_padded+j] += dbeta;
      }
    }


#pragma omp parallel for private(j,s) schedule(runtime)
    for (i=0; i<n; i++) {
        double tmp[NCOLSOUT];
#pragma unroll_and_jam(MIN(16,NCOLSOUT))
        for (s=0; s<NCOLSOUT; s++) {
            tmp[s] = 0.;
#if NCOLSIN > 1
#pragma vector aligned
#pragma vector always
#pragma ivdep
#pragma simd
#endif
#pragma unroll_and_jam(MIN(16,NCOLSIN))
            for (j=0; j<NCOLSIN; j++) {
                tmp[s] += xval[i*ldx+j]*wtmp[s*ncolsin_padded+j];
            }
        }
        memcpy(&xval[i*ldx],tmp,NCOLSOUT*sizeof(double));
    }
    
    free(wtmp);
    
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH)
    return ret;
}
#GHOST_FUNC_END

#GHOST_FUNC_BEGIN#NCOLSIN=${CFG_BLOCKVECTOR_SIZES}
ghost_error_t ghost_tsmm_inplace__plain_d_NCOLSIN_x(ghost_densemat_t *x, ghost_densemat_t *w, void *alpha, void *beta)
{
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH)
    ghost_error_t ret = GHOST_SUCCESS;

    ghost_lidx_t m = x->traits.ncols;
    ghost_lidx_t n = x->traits.nrows;
    ghost_lidx_t ncolsout = w->traits.ncols;

    double dalpha = *(double *)alpha;
    double dbeta = *(double *)beta;
    
    INFO_LOG("In in-place TSMM with arbitrary block size (%"PRLIDX"x%"PRLIDX") <- %f * (%"PRLIDX"x%"PRLIDX") * (%"PRLIDX"x%"PRLIDX")",n,ncolsout,dalpha,n,m,m,ncolsout);

    double * restrict wval = NULL, * restrict xval;
    ghost_lidx_t ldw, ldx;

    ldw = w->stride;
    ldx = x->stride;

    ghost_densemat_valptr(w,(void **)&wval);
    ghost_densemat_valptr(x,(void **)&xval);

    ghost_lidx_t i,j,s;

    /* construct dense wval... we can safely copy it as it is small! */
    double * restrict wtmp = NULL;
    ghost_lidx_t ncolsin_padded = PAD(NCOLSIN,4);
    ghost_malloc_align((void**)&wtmp,ncolsin_padded*ncolsout*sizeof(double),32);
    memset(wtmp,0,ncolsin_padded*ncolsout*sizeof(double));
    for(s=0; s<ncolsout; s++)
    {
      for(j=0; j<NCOLSIN; j++)
      {
        wtmp[s*ncolsin_padded+j] = dalpha*wval[s*ldw+j];
        if(s==j)
          wtmp[s*ncolsin_padded+j] += dbeta;
      }
    }

#pragma omp parallel for private(j,s) schedule(runtime)
    for (i=0; i<n; i++) {
        double tmp[ncolsout];
        for (s=0; s<ncolsout; s++) {
            tmp[s] = 0.;
#if NCOLSIN > 1
#pragma vector aligned
#pragma vector always
#pragma ivdep
#pragma simd
#endif
#pragma unroll_and_jam(MIN(16,NCOLSIN))
            for (j=0; j<NCOLSIN; j++) {
                tmp[s] += xval[i*ldx+j]*wtmp[s*ncolsin_padded+j];
            }
        }
        memcpy(&xval[i*ldx],tmp,ncolsout*sizeof(double));
    }
    
    free(wtmp);
    
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH)
    return ret;
}
#GHOST_FUNC_END

#GHOST_FUNC_BEGIN#NCOLSOUT=${CFG_BLOCKVECTOR_SIZES}
ghost_error_t ghost_tsmm_inplace__plain_d_x_NCOLSOUT(ghost_densemat_t *x, ghost_densemat_t *w, void *alpha, void *beta)
{
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH)
    ghost_error_t ret = GHOST_SUCCESS;

    ghost_lidx_t m = x->traits.ncols;
    ghost_lidx_t n = x->traits.nrows;
    ghost_lidx_t ncolsin = w->traits.nrows;

    double dalpha = *(double *)alpha;
    double dbeta = *(double *)beta;
    
    INFO_LOG("In in-place TSMM with arbitrary block size (%"PRLIDX"x%"PRLIDX") <- %f * (%"PRLIDX"x%"PRLIDX") * (%"PRLIDX"x%"PRLIDX")",n,NCOLSOUT,dalpha,n,m,m,NCOLSOUT);

    double * restrict wval = NULL, * restrict xval;
    ghost_lidx_t ldw, ldx;

    ldw = w->stride;
    ldx = x->stride;

    ghost_densemat_valptr(w,(void **)&wval);
    ghost_densemat_valptr(x,(void **)&xval);

    ghost_lidx_t i,j,s;

    /* construct dense wval... we can safely copy it as it is small! */
    double * restrict wtmp = NULL;
    ghost_lidx_t ncolsin_padded = PAD(ncolsin,4);
    ghost_malloc_align((void**)&wtmp,ncolsin_padded*NCOLSOUT*sizeof(double),32);
    memset(wtmp,0,ncolsin_padded*NCOLSOUT*sizeof(double));
    for(s=0; s<NCOLSOUT; s++)
    {
      for(j=0; j<ncolsin; j++)
      {
        wtmp[s*ncolsin_padded+j] = dalpha*wval[s*ldw+j];
        if(s==j)
          wtmp[s*ncolsin_padded+j] += dbeta;
      }
    }

#pragma omp parallel for private(j,s) schedule(runtime)
    for (i=0; i<n; i++) {
        double tmp[NCOLSOUT];
#pragma unroll_and_jam(MIN(16,NCOLSOUT))
        for (s=0; s<NCOLSOUT; s++) {
            tmp[s] = 0.;
#pragma vector aligned
#pragma vector always
#pragma ivdep
#pragma simd
            for (j=0; j<ncolsin; j++) {
                tmp[s] += xval[i*ldx+j]*wtmp[s*ncolsin_padded+j];
            }
        }
        memcpy(&xval[i*ldx],tmp,NCOLSOUT*sizeof(double));
    }
    
    free(wtmp);
    
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH)
    return ret;
}
#GHOST_FUNC_END

ghost_error_t ghost_tsmm_inplace__plain_d_x_x(ghost_densemat_t *x, ghost_densemat_t *w, void *alpha, void *beta)
{
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH)
    ghost_error_t ret = GHOST_SUCCESS;

    ghost_lidx_t m = x->traits.ncols;
    ghost_lidx_t n = x->traits.nrows;
    ghost_lidx_t ncolsout = w->traits.ncols;
    ghost_lidx_t ncolsin = w->traits.nrows;

    double dalpha = *(double *)alpha;
    double dbeta = *(double *)beta;
    
    INFO_LOG("In in-place TSMM with arbitrary block size (%"PRLIDX"x%"PRLIDX") <- %f * (%"PRLIDX"x%"PRLIDX") * (%"PRLIDX"x%"PRLIDX")",n,ncolsout,dalpha,n,m,ncolsin,ncolsout);

    double * wval = NULL, * xval = NULL;
    ghost_lidx_t ldw, ldx;

    ldw = w->stride;
    ldx = x->stride;

    ghost_densemat_valptr(w,(void **)&wval);
    ghost_densemat_valptr(x,(void **)&xval);

    ghost_lidx_t i,j,s;

    /* construct dense wval... we can safely copy it as it is small! */
    double * restrict wtmp = NULL;
    ghost_lidx_t ncolsin_padded = PAD(ncolsin,4);
    ghost_malloc_align((void**)&wtmp,ncolsin_padded*ncolsout*sizeof(double),32);
    memset(wtmp,0,ncolsin_padded*ncolsout*sizeof(double));
    for(s=0; s<ncolsout; s++)
    {
      for(j=0; j<ncolsin; j++)
      {
        wtmp[s*ncolsin_padded+j] = dalpha*wval[s*ldw+j];
        if(s==j)
          wtmp[s*ncolsin_padded+j] += dbeta;
      }
    }

#pragma omp parallel private(j,s)
    {
        double * restrict tmp = NULL;
        ghost_malloc_align((void**)&tmp,ncolsout*sizeof(double),32);
#pragma omp for schedule(runtime)
        for (i=0; i<n; i++) {
            for (s=0; s<ncolsout; s++) {
                tmp[s] = 0.;
#pragma vector aligned
#pragma vector always
#pragma ivdep
#pragma simd
                for (j=0; j<ncolsin; j++) {
                    tmp[s] += xval[i*ldx+j]*wtmp[s*ncolsin_padded+j];
                }
            }
            memcpy(&xval[i*ldx],tmp,ncolsout*sizeof(double));
        }
        free(tmp);
    }

    free(wtmp);
    
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH)
    return ret;
}

ghost_error_t ghost_tsmm_inplace__plain_z_x_x(ghost_densemat_t *x, ghost_densemat_t *w, void *alpha, void *beta)
{
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH)
    ghost_error_t ret = GHOST_SUCCESS;

    ghost_lidx_t m = x->traits.ncols;
    ghost_lidx_t n = x->traits.nrows;
    ghost_lidx_t ncolsout = w->traits.ncols;
    ghost_lidx_t ncolsin = w->traits.nrows;

    double complex dalpha = *(double complex *)alpha;
    double complex dbeta = *(double complex *)beta;
    
    INFO_LOG("In in-place TSMM with arbitrary block size (%"PRLIDX"x%"PRLIDX") <- %f+I*%f * (%"PRLIDX"x%"PRLIDX") * (%"PRLIDX"x%"PRLIDX")",n,m,creal(dalpha),cimag(dalpha),n,m,m,m);

    double complex * restrict wval = NULL, * restrict xval;
    ghost_lidx_t ldw, ldx;

    ldw = w->stride;
    ldx = x->stride;

    ghost_densemat_valptr(w,(void **)&wval);
    ghost_densemat_valptr(x,(void **)&xval);

    ghost_lidx_t i,j,s;

#pragma omp parallel private(j,s)
    {
#pragma omp for schedule(runtime)
        for (i=0; i<n; i++) {
            double complex tmp[ncolsout];
            for (s=0; s<ncolsout; s++) {
                tmp[s] = dbeta*xval[i*ldx+s];
#pragma vector aligned
#pragma vector always
#pragma ivdep
#pragma simd
                for (j=0; j<ncolsin; j++) {
                    tmp[s] += dalpha*xval[i*ldx+j]*wval[s*ldw+j];
                }
            }
            memcpy(&xval[i*ldx],tmp,ncolsout*sizeof(double complex));
        }
    }
    
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH)
    return ret;
}

