const char *kernelSource = "#if defined(cl_khr_fp64)\n"
"#pragma OPENCL EXTENSION cl_khr_fp64 : enable\n"
"#elif defined(cl_amd_fp64)\n"
"#pragma OPENCL EXTENSION cl_amd_fp64 : enable\n"
"#endif\n"
"\n"
"#if defined(cl_intel_printf)\n"
"#pragma OPENCL EXTENSION cl_intel_printf : enable\n"
"#elif defined(cl_amd_printf)\n"
"#pragma OPENCL EXTENSION cl_amd_printf : enable\n"
"#endif\n"
"\n"
"#ifdef DOUBLE\n"
"#ifdef COMPLEX\n"
"typedef double2 cl_data_t;\n"
"#else\n"
"typedef double cl_data_t;\n"
"#endif\n"
"#endif\n"
"#ifdef SINGLE\n"
"#ifdef COMPLEX\n"
"typedef float2 cl_data_t;\n"
"#else\n"
"typedef float cl_data_t;\n"
"#endif\n"
"#endif\n"
"\n"
"kernel void pJDS1kernel (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, global cl_data_t *val, global int *col, global int *rowLen, global int *colStart) {\n"
"\n"
"	int row = get_global_id(0);\n"
"	cl_data_t svalue = 0.0, value, rhs;\n"
"	int i, idcol;\n"
"\n"
"	if (row < nRows) {\n"
"		for( i = 0; i < rowLen[row]; ++i) {\n"
"			value = val[colStart[i]+row];\n"
"			idcol = col[colStart[i]+row];\n"
"			rhs = rhsVec[idcol];\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		}\n"
"		resVec[row] = svalue;\n"
"	}\n"
"\n"
"}\n"
"\n"
"kernel void ELR1kernel (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows,\n"
"	   	int pad, global cl_data_t *val, global int *col, global int *rowLen) \n"
"{\n"
"	int row = get_global_id(0);\n"
"	cl_data_t svalue = 0.0, value, rhs;\n"
"	int i, idcol;\n"
"	\n"
"	if (row < nRows) {\n"
"		for( i = 0; i < rowLen[row]; ++i) {\n"
"			value = val[i*pad+row];\n"
"			idcol = col[i*pad+row];\n"
"			rhs = rhsVec[idcol];\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		}\n"
"		resVec[row] = svalue;\n"
"	}\n"
"}\n"
"\n"
"kernel void pJDS2kernel (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, global cl_data_t *val, global int *col, global int *rowLen, global int *colStart, local cl_data_t *shared) {\n"
"\n"
"	unsigned int row  = get_global_id(0)>>1;\n"
"	if (row < nRows) {\n"
"			unsigned int idcol;\n"
"		unsigned short idb, k;\n"
"		cl_data_t svalue, value, rhs;\n"
"\n"
"		idb  = get_local_id(0)%2;\n"
"\n"
"		svalue = 0.0;\n"
"		for( k = 0; k < rowLen[row]; ++k)\n"
"		{\n"
"			value = val[colStart[k]+row*2+idb];\n"
"			idcol = col[colStart[k]+row*2+idb];\n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		shared[get_local_id(0)] = svalue;\n"
"\n"
"		if (idb==0) {\n"
"			resVec[row] = shared[get_local_id(0)]+shared[get_local_id(0)+1];\n"
"		}\n"
"	}\n"
"} \n"
"\n"
"kernel void ELR2kernel (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, int pad, global cl_data_t *val, global int *col, global int *rowLen, local cl_data_t *shared) {\n"
"	unsigned int row  = get_global_id(0)>>1;\n"
"\n"
"	if (row < nRows) {\n"
"		unsigned int idcol;\n"
"		unsigned short idb, k;\n"
"		cl_data_t svalue, value, rhs;\n"
"\n"
"		idb  = get_local_id(0)%2;\n"
"		svalue = 0.0;\n"
"		for(k=0; k<rowLen[row]; ++k){ \n"
"\n"
"			value = val[k*pad*2 + 2*row + idb]; \n"
"			idcol = col[k*pad*2 + 2*row + idb]; \n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		} \n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		shared[get_local_id(0)] = svalue;\n"
"\n"
"		if (idb==0) {\n"
"			resVec[row] = shared[get_local_id(0)]+shared[get_local_id(0)+1];\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"kernel void pJDS4kernel (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, global cl_data_t *val, global int *col, global int *rowLen, global int *colStart, local cl_data_t *shared) {\n"
"\n"
"	unsigned int row  = get_global_id(0)>>2;\n"
"	if (row < nRows) {\n"
"		unsigned int idcol;\n"
"		unsigned short idb, k;\n"
"		cl_data_t svalue, value, rhs;\n"
"\n"
"		idb  = get_local_id(0)%4;\n"
"\n"
"		svalue = 0.0;\n"
"		for( k = 0; k < rowLen[row]; ++k)\n"
"		{\n"
"			value = val[colStart[k]+row*4+idb];\n"
"			idcol = col[colStart[k]+row*4+idb];\n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		shared[get_local_id(0)] = svalue;\n"
"\n"
"		if (idb<2)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+2];\n"
"\n"
"		if (idb==0) {\n"
"			resVec[row] = shared[get_local_id(0)]+shared[get_local_id(0)+1];\n"
"		}\n"
"	}\n"
"} \n"
"\n"
"kernel void ELR4kernel (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, int pad, global cl_data_t *val, global int *col, global int *rowLen, local cl_data_t *shared) {\n"
"	unsigned int row  = get_global_id(0)>>2;\n"
"\n"
"	if (row < nRows) {\n"
"		unsigned int idcol;\n"
"		unsigned short idb, k;\n"
"		cl_data_t svalue, value, rhs;\n"
"\n"
"		idb  = get_local_id(0)%4;\n"
"		svalue = 0.0;\n"
"		for(k=0; k<rowLen[row]; ++k){ \n"
"\n"
"			value = val[k*pad*4 + 4*row + idb]; \n"
"			idcol = col[k*pad*4 + 4*row + idb]; \n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		} \n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		shared[get_local_id(0)] = svalue;\n"
"\n"
"		if (idb<2)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+2];\n"
"\n"
"		if (idb==0) {\n"
"			resVec[row] = shared[get_local_id(0)]+shared[get_local_id(0)+1];\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"kernel void pJDS8kernel (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, global cl_data_t *val, global int *col, global int *rowLen, global int *colStart, local cl_data_t *shared) {\n"
"\n"
"	unsigned int row  = get_global_id(0)>>3;\n"
"	if (row < nRows) {\n"
"		unsigned int idcol;\n"
"		unsigned short idb, k;\n"
"		cl_data_t svalue, value, rhs;\n"
"\n"
"		idb  = get_local_id(0)%8;\n"
"\n"
"		svalue = 0.0;\n"
"		for( k = 0; k < rowLen[row]; ++k)\n"
"		{\n"
"			value = val[colStart[k]+row*8+idb];\n"
"			idcol = col[colStart[k]+row*8+idb];\n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		shared[get_local_id(0)] = svalue;\n"
"\n"
"		if (idb<4)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+4];\n"
"		if (idb<2)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+2];\n"
"\n"
"		if (idb==0) {\n"
"			resVec[row] = shared[get_local_id(0)]+shared[get_local_id(0)+1];\n"
"		}\n"
"	}\n"
"} \n"
"\n"
"kernel void ELR8kernel (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, int pad, global cl_data_t *val, global int *col, global int *rowLen, local cl_data_t *shared) {\n"
"	unsigned int row  = get_global_id(0)>>3;\n"
"\n"
"	if (row < nRows) {\n"
"		unsigned int idcol;\n"
"		unsigned short idb, k;\n"
"		cl_data_t svalue, value, rhs;\n"
"\n"
"		idb  = get_local_id(0)%8;\n"
"		svalue = 0.0;\n"
"		for(k=0; k<rowLen[row]; ++k){ \n"
"\n"
"			value = val[k*pad*8 + 8*row + idb]; \n"
"			idcol = col[k*pad*8 + 8*row + idb]; \n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		} \n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		shared[get_local_id(0)] = svalue;\n"
"\n"
"		if (idb<4)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+4];\n"
"		if (idb<2)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+2];\n"
"\n"
"		if (idb==0) {\n"
"			resVec[row] = shared[get_local_id(0)]+shared[get_local_id(0)+1];\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"kernel void pJDS16kernel (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, global cl_data_t *val, global int *col, global int *rowLen, global int *colStart, local cl_data_t *shared) {\n"
"\n"
"	unsigned int row  = get_global_id(0)>>4;\n"
"	if (row < nRows) {\n"
"		unsigned int idcol;\n"
"		unsigned short idb, k;\n"
"		cl_data_t svalue, value, rhs;\n"
"\n"
"		idb  = get_local_id(0)%16;\n"
"\n"
"		svalue = 0.0;\n"
"		for( k = 0; k < rowLen[row]; ++k)\n"
"		{\n"
"			value = val[colStart[k]+row*16+idb];\n"
"			idcol = col[colStart[k]+row*16+idb];\n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		shared[get_local_id(0)] = svalue;\n"
"\n"
"		if (idb<8)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+8];\n"
"		if (idb<4)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+4];\n"
"		if (idb<2)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+2];\n"
"\n"
"		if (idb==0) {\n"
"			resVec[row] = shared[get_local_id(0)]+shared[get_local_id(0)+1];\n"
"		}\n"
"	}\n"
"} \n"
"\n"
"kernel void ELR16kernel (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, int pad, global cl_data_t *val, global int *col, global int *rowLen, local cl_data_t *shared) {\n"
"	unsigned int row  = get_global_id(0)>>4;\n"
"\n"
"	if (row < nRows) {\n"
"		unsigned int idcol;\n"
"		unsigned short idb, k;\n"
"		cl_data_t svalue, value, rhs;\n"
"\n"
"		idb  = get_local_id(0)%16;\n"
"		svalue = 0.0;\n"
"		for(k=0; k<rowLen[row]; ++k){ \n"
"\n"
"			value = val[k*pad*16 + 16*row + idb]; \n"
"			idcol = col[k*pad*16 + 16*row + idb]; \n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		} \n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		shared[get_local_id(0)] = svalue;\n"
"\n"
"		if (idb<8)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+8];\n"
"		if (idb<4)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+4];\n"
"		if (idb<2)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+2];\n"
"\n"
"		if (idb==0) {\n"
"			resVec[row] = shared[get_local_id(0)]+shared[get_local_id(0)+1];\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"kernel void pJDS1kernelAdd (global cl_data_t *resVec, global cl_data_t *rhsVec, \n"
"		int nRows, global cl_data_t *val, global int *col, global int *rowLen, \n"
"		global int *colStart) {\n"
"\n"
"	int row = get_global_id(0);\n"
"	cl_data_t svalue = 0.0, value, rhs;\n"
"	int i, idcol;\n"
"\n"
"	if (row < nRows) {\n"
"		for( i = 0; i < rowLen[row]; ++i) {\n"
"			value = val[colStart[i]+row];\n"
"			idcol = col[colStart[i]+row];\n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		}\n"
"		resVec[row] += svalue;\n"
"	}\n"
"\n"
"}\n"
"\n"
"kernel void ELR1kernelAdd (global cl_data_t *resVec, global cl_data_t *rhsVec, \n"
"		int nRows, int pad, global cl_data_t *val, global int *col, \n"
"		global int *rowLen) {\n"
"\n"
"	int row = get_global_id(0);\n"
"	cl_data_t svalue = 0.0, value, rhs;\n"
"	int i, idcol;\n"
"	if (row < nRows) {\n"
"		for( i = 0; i < rowLen[row]; ++i) {\n"
"			value = val[i*pad+row];\n"
"			idcol = col[i*pad+row];\n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		}\n"
"		resVec[row] += svalue;\n"
"\n"
"	}\n"
"}\n"
"\n"
"kernel void pJDS2kernelAdd (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, global cl_data_t *val, global int *col, global int *rowLen, global int *colStart, local cl_data_t *shared) {\n"
"\n"
"	unsigned int row  = get_global_id(0)>>1;\n"
"	if (row < nRows) {\n"
"		unsigned int idcol;\n"
"		unsigned short idb, k;\n"
"		cl_data_t svalue, value, rhs;\n"
"\n"
"		idb  = get_local_id(0)%2;\n"
"\n"
"		svalue = 0.0;\n"
"		for( k = 0; k < rowLen[row]; ++k)\n"
"		{\n"
"			value = val[colStart[k]+row*2+idb];\n"
"			idcol = col[colStart[k]+row*2+idb];\n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		shared[get_local_id(0)] = svalue;\n"
"\n"
"		if (idb==0) {\n"
"			resVec[row] += shared[get_local_id(0)]+shared[get_local_id(0)+1];\n"
"		}\n"
"	}\n"
"} \n"
"\n"
"kernel void ELR2kernelAdd (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, int pad, global cl_data_t *val, global int *col, global int *rowLen, local cl_data_t *shared) {\n"
"	unsigned int row  = get_global_id(0)>>1;\n"
"\n"
"	if (row < nRows) {\n"
"		unsigned int idcol;\n"
"		unsigned short idb, k;\n"
"		cl_data_t svalue, value, rhs;\n"
"\n"
"		idb  = get_local_id(0)%2;\n"
"		svalue = 0.0;\n"
"		for(k=0; k<rowLen[row]; ++k){ \n"
"\n"
"			value = val[k*pad*2 + 2*row + idb]; \n"
"			idcol = col[k*pad*2 + 2*row + idb]; \n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		} \n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		shared[get_local_id(0)] = svalue;\n"
"\n"
"		if (idb==0) {\n"
"			resVec[row] += shared[get_local_id(0)]+shared[get_local_id(0)+1];\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"kernel void pJDS4kernelAdd (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, global cl_data_t *val, global int *col, global int *rowLen, global int *colStart, local cl_data_t *shared) {\n"
"\n"
"	unsigned int row  = get_global_id(0)>>2;\n"
"	if (row < nRows) {\n"
"		unsigned int idcol;\n"
"		unsigned short idb, k;\n"
"		cl_data_t svalue, value, rhs;\n"
"\n"
"		idb  = get_local_id(0)%4;\n"
"\n"
"		svalue = 0.0;\n"
"		for( k = 0; k < rowLen[row]; ++k)\n"
"		{\n"
"			value = val[colStart[k]+row*4+idb];\n"
"			idcol = col[colStart[k]+row*4+idb];\n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		shared[get_local_id(0)] = svalue;\n"
"\n"
"		if (idb<2)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+2];\n"
"\n"
"		if (idb==0) {\n"
"			resVec[row] += shared[get_local_id(0)]+shared[get_local_id(0)+1];\n"
"		}\n"
"	}\n"
"} \n"
"\n"
"kernel void ELR4kernelAdd (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, int pad, global cl_data_t *val, global int *col, global int *rowLen, local cl_data_t *shared) {\n"
"	unsigned int row  = get_global_id(0)>>2;\n"
"\n"
"	if (row < nRows) {\n"
"		unsigned int idcol;\n"
"		unsigned short idb, k;\n"
"		cl_data_t svalue, value, rhs;\n"
"\n"
"		idb  = get_local_id(0)%4;\n"
"		svalue = 0.0;\n"
"		for(k=0; k<rowLen[row]; ++k){ \n"
"\n"
"			value = val[k*pad*4 + 4*row + idb]; \n"
"			idcol = col[k*pad*4 + 4*row + idb]; \n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		} \n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		shared[get_local_id(0)] = svalue;\n"
"\n"
"		if (idb<2)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+2];\n"
"\n"
"		if (idb==0) {\n"
"			resVec[row] += shared[get_local_id(0)]+shared[get_local_id(0)+1];\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"kernel void pJDS8kernelAdd (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, global cl_data_t *val, global int *col, global int *rowLen, global int *colStart, local cl_data_t *shared) {\n"
"\n"
"	unsigned int row  = get_global_id(0)>>3;\n"
"	if (row < nRows) {\n"
"		unsigned int idcol;\n"
"		unsigned short idb, k;\n"
"		cl_data_t svalue, value, rhs;\n"
"\n"
"		idb  = get_local_id(0)%8;\n"
"\n"
"		svalue = 0.0;\n"
"		for( k = 0; k < rowLen[row]; ++k)\n"
"		{\n"
"			value = val[colStart[k]+row*8+idb];\n"
"			idcol = col[colStart[k]+row*8+idb];\n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		shared[get_local_id(0)] = svalue;\n"
"\n"
"		if (idb<4)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+4];\n"
"		if (idb<2)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+2];\n"
"\n"
"		if (idb==0) {\n"
"			resVec[row] += shared[get_local_id(0)]+shared[get_local_id(0)+1];\n"
"		}\n"
"	}\n"
"} \n"
"\n"
"kernel void ELR8kernelAdd (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, int pad, global cl_data_t *val, global int *col, global int *rowLen, local cl_data_t *shared) {\n"
"	unsigned int row  = get_global_id(0)>>3;\n"
"\n"
"	if (row < nRows) {\n"
"		unsigned int idcol;\n"
"		unsigned short idb, k;\n"
"		cl_data_t svalue, value, rhs;\n"
"\n"
"		idb  = get_local_id(0)%8;\n"
"		svalue = 0.0;\n"
"		for(k=0; k<rowLen[row]; ++k){ \n"
"\n"
"			value = val[k*pad*8 + 8*row + idb]; \n"
"			idcol = col[k*pad*8 + 8*row + idb]; \n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		} \n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		shared[get_local_id(0)] = svalue;\n"
"\n"
"		if (idb<4)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+4];\n"
"		if (idb<2)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+2];\n"
"\n"
"		if (idb==0) {\n"
"			resVec[row] += shared[get_local_id(0)]+shared[get_local_id(0)+1];\n"
"		}\n"
"	}\n"
"}\n"
"\n"
"kernel void pJDS16kernelAdd (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, global cl_data_t *val, global int *col, global int *rowLen, global int *colStart, local cl_data_t *shared) {\n"
"\n"
"	unsigned int row  = get_global_id(0)>>4;\n"
"	if (row < nRows) {\n"
"		unsigned int idcol;\n"
"		unsigned short idb, k;\n"
"		cl_data_t svalue, value, rhs;\n"
"\n"
"		idb  = get_local_id(0)%16;\n"
"\n"
"		svalue = 0.0;\n"
"		for( k = 0; k < rowLen[row]; ++k)\n"
"		{\n"
"			value = val[colStart[k]+row*16+idb];\n"
"			idcol = col[colStart[k]+row*16+idb];\n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		}\n"
"\n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		shared[get_local_id(0)] = svalue;\n"
"\n"
"		if (idb<8)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+8];\n"
"		if (idb<4)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+4];\n"
"		if (idb<2)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+2];\n"
"\n"
"		if (idb==0) {\n"
"			resVec[row] += shared[get_local_id(0)]+shared[get_local_id(0)+1];\n"
"		}\n"
"	}\n"
"} \n"
"\n"
"kernel void ELR16kernelAdd (global cl_data_t *resVec, global cl_data_t *rhsVec, int nRows, int pad, global cl_data_t *val, global int *col, global int *rowLen, local cl_data_t *shared) {\n"
"	unsigned int row  = get_global_id(0)>>4;\n"
"\n"
"	if (row < nRows) {\n"
"		unsigned int idcol;\n"
"		unsigned short idb, k;\n"
"		cl_data_t svalue, value, rhs;\n"
"\n"
"		idb  = get_local_id(0)%16;\n"
"		svalue = 0.0;\n"
"		for(k=0; k<rowLen[row]; ++k){ \n"
"\n"
"			value = val[k*pad*16 + 16*row + idb]; \n"
"			idcol = col[k*pad*16 + 16*row + idb]; \n"
"			rhs = rhsVec[idcol];\n"
"\n"
"#ifdef COMPLEX\n"
"			svalue.s0 += (value.s0*rhs.s0 - value.s1*rhs.s1);\n"
"			svalue.s1 += (value.s0*rhs.s1 + value.s1*rhs.s0);\n"
"#else\n"
"			svalue += value*rhs;\n"
"#endif\n"
"		} \n"
"		barrier(CLK_LOCAL_MEM_FENCE);\n"
"\n"
"		shared[get_local_id(0)] = svalue;\n"
"\n"
"		if (idb<8)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+8];\n"
"		if (idb<4)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+4];\n"
"		if (idb<2)\n"
"			shared[get_local_id(0)]+=shared[get_local_id(0)+2];\n"
"\n"
"		if (idb==0) {\n"
"			resVec[row] += shared[get_local_id(0)]+shared[get_local_id(0)+1];\n"
"		}\n"
"	}\n"
"}\n"
"\n";
