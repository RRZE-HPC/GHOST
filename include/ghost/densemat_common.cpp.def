#include "ghost/config.h"
#include "ghost/omp.h"

#ifdef GHOST_HAVE_MPI
#include <mpi.h> //mpi.h has to be included before stdio.h
#endif
#include <cstdlib>
#include <iostream>
#include <iomanip>
#include <complex>
#include <stdio.h>

#include "ghost/complex.h"
#include "ghost/rand.h"
#include "ghost/util.h"
#include "ghost/densemat_cm.h"
#include "ghost/densemat_rm.h"
#include "ghost/math.h"
#include "ghost/locality.h"
#include "ghost/log.h"
#include "ghost/machine.h"

#define DENSEMAT_DT v_t
#include "ghost/densemat_iter_macros.h"

#ifdef ROWMAJOR
#ifdef COLMAJOR
#error "Only one of ROWMAJOR or COLMAJOR must be defined!"
#endif
#define PREFIX rm
#elif defined (COLMAJOR)
#define PREFIX cm
#else
#error "One of ROWMAJOR or COLMAJOR must be defined!"
#endif


#define PASTER(x,y) x ## _ ## y
#define EVALUATOR(x,y) PASTER(x,y)
#define FUNCNAME(fun) EVALUATOR(ghost_densemat,EVALUATOR(PREFIX,fun))

using namespace std;

template<typename v_t>
static ghost_error_t FUNCNAME(normalize_tmpl(ghost_densemat_t *vec))
{
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH);
    ghost_error_t ret = GHOST_SUCCESS;
    ghost_lidx_t v;
    v_t *s = NULL;

    GHOST_CALL_GOTO(ghost_malloc((void **)&s,vec->traits.ncols*sizeof(v_t)),err,ret);
    GHOST_CALL_GOTO(ghost_dot(s,vec,vec),err,ret);

    for (v=0; v<vec->traits.ncols; v++) {
        s[v] = (v_t)sqrt(s[v]);
        s[v] = (v_t)(((v_t)1.)/s[v]);
    }
    GHOST_CALL_GOTO(vec->vscale(vec,s),err,ret);

    goto out;
err:

out:
    free(s);

    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH);
    return ret;
}

template <typename v_t> 
static ghost_error_t FUNCNAME(dotprod_tmpl(ghost_densemat_t *vec, void *res, ghost_densemat_t *vec2))
{ 
    // the parallelization is done manually because reduction does not work with ghost_complex numbers
   
    GHOST_DENSEMAT_CHECK_SIMILARITY(vec,vec2);
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH|GHOST_FUNCTYPE_KERNEL);

    ghost_error_t ret = GHOST_SUCCESS;
    int nthreads, i;
    v_t *partsums;
    unsigned clsize;

#pragma omp parallel
    {
#pragma omp single
    nthreads = ghost_omp_nthread();
    }
   
    ghost_machine_cacheline_size(&clsize);
    int padding = (8*(int)clsize)/sizeof(v_t);
    int ncolsPadded = PAD(vec->traits.ncols,padding);
        
    GHOST_CALL_GOTO(ghost_malloc_align((void **)&partsums,nthreads*ncolsPadded*sizeof(v_t),64),err,ret);
    memset(partsums,0,nthreads*ncolsPadded*sizeof(v_t));
   
    if (vec == vec2) { 
#pragma omp parallel shared(partsums) 
        {
            int tid = ghost_omp_threadnum();
            DENSEMAT_ITER(vec,
                partsums[ncolsPadded*tid+col] += *valptr * 
                    conjugate(valptr));
        }
    } else {
#pragma omp parallel shared(partsums) 
        {
            int tid = ghost_omp_threadnum();
            DENSEMAT_ITER2(vec,vec2,
                partsums[ncolsPadded*tid+col] += *valptr2 * 
                    conjugate(valptr1));
        }
    }
    
    ghost_lidx_t col;
    for (col=0; col<vec->traits.ncols; col++) {
        ((v_t *)res)[col] = 0.;

        for (i=0; i<nthreads; i++) {
            ((v_t *)res)[col] += partsums[i*ncolsPadded+col];
        }
    }

    goto out;
err:

out:
    free(partsums);
    
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH|GHOST_FUNCTYPE_KERNEL);
    return ret;
}

template <typename v_t> 
static ghost_error_t FUNCNAME(norm_tmpl(ghost_densemat_t *vec, void *res, void *p))
{ 
    // the parallelization is done manually because reduction does not work with ghost_complex numbers
   
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH|GHOST_FUNCTYPE_KERNEL);

    ghost_error_t ret = GHOST_SUCCESS;
    int nthreads, i;
    v_t *partsums;
    unsigned clsize;

#pragma omp parallel
    {
#pragma omp single
    nthreads = ghost_omp_nthread();
    }
   
    ghost_machine_cacheline_size(&clsize);
    int padding = 8*(int)clsize/sizeof(v_t);
        
    GHOST_CALL_GOTO(ghost_malloc_align((void **)&partsums,nthreads*(vec->traits.ncols+padding)*sizeof(v_t),64),err,ret);
    memset(partsums,0,nthreads*(vec->traits.ncols+padding)*sizeof(v_t));
   
#pragma omp parallel shared(partsums) 
    {
        int tid = ghost_omp_threadnum();
        DENSEMAT_ITER(vec,partsums[(padding+vec->traits.ncols)*tid+col] += pow(*(v_t *)valptr * 
                conjugate((v_t *)valptr),*(v_t *)p));
    }
    
    ghost_lidx_t col;
    for (col=0; col<vec->traits.ncols; col++) {
        ((v_t *)res)[col] = 0.;

        for (i=0; i<nthreads; i++) {
            ((v_t *)res)[col] += partsums[i*(vec->traits.ncols+padding)+col];
        }
    }

    goto out;
err:

out:
    free(partsums);
    
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH|GHOST_FUNCTYPE_KERNEL);
    return ret;
}

template <typename v_t> 
static ghost_error_t FUNCNAME(vaxpy_tmpl(ghost_densemat_t *vec, ghost_densemat_t *vec2, void *scale))
{
    GHOST_DENSEMAT_CHECK_SIMILARITY(vec,vec2);
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH|GHOST_FUNCTYPE_KERNEL);
    
    v_t *s = (v_t *)scale;
    
    DENSEMAT_ITER2(vec,vec2,*(v_t *)valptr1 += *(v_t *)valptr2 * s[col]);

    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH|GHOST_FUNCTYPE_KERNEL);
    return GHOST_SUCCESS;
}

template <typename v_t> 
static ghost_error_t FUNCNAME(vaxpby_tmpl(ghost_densemat_t *vec, ghost_densemat_t *vec2, void *scale, void *b_))
{
    GHOST_DENSEMAT_CHECK_SIMILARITY(vec,vec2);
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH|GHOST_FUNCTYPE_KERNEL);

    v_t *s = (v_t *)scale;
    v_t *b = (v_t *)b_;

    DENSEMAT_ITER2(vec,vec2,*(v_t *)valptr1 = *(v_t *)valptr2 * s[col] + 
            *(v_t *)valptr1 * b[col]);
    
    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH|GHOST_FUNCTYPE_KERNEL);
    return GHOST_SUCCESS;
}

template<typename v_t> 
static ghost_error_t FUNCNAME(vscale_tmpl(ghost_densemat_t *vec, void *scale))
{
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_MATH|GHOST_FUNCTYPE_KERNEL);
        
    DENSEMAT_ITER(vec,*(v_t *)valptr *= ((v_t *)scale)[col]);

    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_MATH|GHOST_FUNCTYPE_KERNEL);
    return GHOST_SUCCESS;
}

// thread-safe type generic random function, returns pseudo-random numbers between -1 and 1.
template <typename v_t>
static inline void my_rand(unsigned int* state, v_t* result)
{
    // default implementation
    static const v_t scal = (v_t)2.0/(v_t)RAND_MAX;
    static const v_t shift=(v_t)(-1.0);
    *result=(v_t)rand_r(state)*scal+shift;
}

template <typename float_type>
static void my_rand(unsigned int* state, std::complex<float_type>* result)
{
    float_type* ft_res = (float_type*)result;
    my_rand(state,&ft_res[0]);
    my_rand(state,&ft_res[1]);
}

template <typename float_type>
static inline void my_rand(unsigned int* state, ghost_complex<float_type>* result)
{
    my_rand<float_type>(state,(float_type *)result);
    my_rand<float_type>(state,((float_type *)result)+1);
}

template<typename v_t>
struct ghost_densemat_perment_t {
    v_t val;
    ghost_gidx_t pidx;
};

template <typename v_t> 
static int densemat_perment_cmp (const void *a, const void *b)
{
    return ((ghost_densemat_perment_t<v_t> *)a)->pidx - ((ghost_densemat_perment_t<v_t> *)b)->pidx;

}


template <typename v_t> 
static ghost_error_t FUNCNAME(permute_tmpl(ghost_densemat_t *vec, ghost_permutation_direction_t dir))
{
    if (!vec->context->perm_local && !vec->context->perm_global) {
        WARNING_LOG("No permutation vector present!");
        return GHOST_SUCCESS;
    }

    if (vec->context->perm_global) {
#ifdef GHOST_HAVE_MPI
        ghost_lidx_t colidx;
        ghost_lidx_t i,me,nprocs;
        
        int blocklengths[] = {1,1};
        MPI_Aint displacements[2];
        displacements[0] = 0;
        displacements[1] = sizeof(v_t);
        ghost_mpi_datatype_t types[] = {vec->mpidt,ghost_mpi_dt_gidx};

        ghost_mpi_datatype_t ghost_mpi_dt_densemat_perment;
        MPI_CALL_RETURN(MPI_Type_create_struct(2,blocklengths,displacements,types,&ghost_mpi_dt_densemat_perment));
        MPI_CALL_RETURN(MPI_Type_commit(&ghost_mpi_dt_densemat_perment));
            
        GHOST_CALL_RETURN(ghost_rank(&me,vec->context->mpicomm));
        GHOST_CALL_RETURN(ghost_nrank(&nprocs,vec->context->mpicomm));
        GHOST_CALL_RETURN(vec->download(vec));
            
        int* permcnt, *invpermcnt, *permdispl, *invpermdispl;
        GHOST_CALL_RETURN(ghost_malloc((void **)&permcnt,nprocs*sizeof(int)));
        GHOST_CALL_RETURN(ghost_malloc((void **)&invpermcnt,nprocs*sizeof(int)));
        GHOST_CALL_RETURN(ghost_malloc((void **)&permdispl,nprocs*sizeof(int)));
        GHOST_CALL_RETURN(ghost_malloc((void **)&invpermdispl,nprocs*sizeof(int)));

        for (colidx=0; colidx<vec->traits.ncols; colidx++) {
            struct ghost_densemat_perment_t<v_t> *permsorted, *invpermsorted;

            GHOST_CALL_RETURN(ghost_malloc((void **)&permsorted,sizeof(struct ghost_densemat_perment_t<v_t>)*vec->context->perm_global->len));
            GHOST_CALL_RETURN(ghost_malloc((void **)&invpermsorted,sizeof(struct ghost_densemat_perment_t<v_t>)*vec->context->perm_global->len));

            for (i=0; i<vec->context->perm_global->len; i++) {
                if (vec->context->perm_local && dir == GHOST_PERMUTATION_PERM2ORIG) {
                    permsorted[i].val = *(v_t *)DENSEMAT_VALPTR(vec,i,colidx);
                    invpermsorted[i].val = *(v_t *)DENSEMAT_VALPTR(vec,i,colidx);
                    permsorted[i].pidx = vec->context->perm_global->perm[vec->context->perm_local->perm[i]];
                    invpermsorted[i].pidx = vec->context->perm_global->invPerm[vec->context->perm_local->invPerm[i]];
                } else {
                    permsorted[i].val = *(v_t *)DENSEMAT_VALPTR(vec,i,colidx);
                    invpermsorted[i].val = *(v_t *)DENSEMAT_VALPTR(vec,i,colidx);
                    permsorted[i].pidx = vec->context->perm_global->perm[i];
                    invpermsorted[i].pidx = vec->context->perm_global->invPerm[i];
                }
                
            }
            qsort(permsorted,vec->context->perm_global->len,sizeof(struct ghost_densemat_perment_t<v_t>),densemat_perment_cmp<v_t>);
            qsort(invpermsorted,vec->context->perm_global->len,sizeof(struct ghost_densemat_perment_t<v_t>),densemat_perment_cmp<v_t>);


            memset(permcnt,0,nprocs*sizeof(int));
            memset(invpermcnt,0,nprocs*sizeof(int));
            memset(permdispl,0,nprocs*sizeof(int));
            memset(invpermdispl,0,nprocs*sizeof(int));

            int permproc = 0, invpermproc = 0;
            for (i=0; i<vec->context->perm_global->len; i++) {
                while (permsorted[i].pidx >= (vec->context->lfRow[permproc]+vec->context->lnrows[permproc])) {
                    permproc++;
                }
                while (invpermsorted[i].pidx >= (vec->context->lfRow[invpermproc]+vec->context->lnrows[invpermproc])) {
                    invpermproc++;
                }
                permcnt[permproc]++;
                invpermcnt[invpermproc]++;
            }
            for (i=1; i<nprocs; i++) {
                permdispl[i] = permdispl[i-1]+permcnt[i-1];
                invpermdispl[i] = invpermdispl[i-1]+invpermcnt[i-1];
            }

            if (dir == GHOST_PERMUTATION_ORIG2PERM) {
                MPI_CALL_RETURN(MPI_Alltoallv(permsorted,permcnt,permdispl,ghost_mpi_dt_densemat_perment,invpermsorted,invpermcnt,invpermdispl,ghost_mpi_dt_densemat_perment,vec->context->mpicomm));
                if (vec->context->perm_local) {
                    for (i=0; i<vec->context->perm_global->len; i++) {
                        *(v_t *)DENSEMAT_VALPTR(vec,vec->context->perm_local->perm[invpermsorted[i].pidx-vec->context->lfRow[me]],colidx) = invpermsorted[i].val;
                    }
                } else {
                    for (i=0; i<vec->context->perm_global->len; i++) {
                        *(v_t *)DENSEMAT_VALPTR(vec,i,colidx) = invpermsorted[i].val;
                    }
                }
            } else {
                MPI_CALL_RETURN(MPI_Alltoallv(invpermsorted,invpermcnt,invpermdispl,ghost_mpi_dt_densemat_perment,permsorted,permcnt,permdispl,ghost_mpi_dt_densemat_perment,vec->context->mpicomm));
                for (i=0; i<vec->context->perm_global->len; i++) {
                    *(v_t *)DENSEMAT_VALPTR(vec,permsorted[i].pidx-vec->context->lfRow[me],colidx) = permsorted[i].val;
                }
            }

            free(permsorted);
            free(invpermsorted);
        }
        MPI_Type_free(&ghost_mpi_dt_densemat_perment);
        free(permcnt);
        free(invpermcnt);
        free(permdispl);
        free(invpermdispl);
#else
        ERROR_LOG("There should not be a global permutation in case MPI is disabled!");
#endif
    } else if (vec->context->perm_local) {
        ghost_densemat_t *vecclone;

        vec->clone(vec,&vecclone,vec->traits.nrows,0,vec->traits.ncols,0);

        if (dir == GHOST_PERMUTATION_ORIG2PERM) {
            DENSEMAT_ITER(vec,*valptr = *(v_t *)DENSEMAT_VALPTR(vecclone,vec->context->perm_local->invPerm[row],col));
        } else {
            DENSEMAT_ITER(vec,*valptr = *(v_t *)DENSEMAT_VALPTR(vecclone,vec->context->perm_local->perm[row],col));
        }

        vecclone->destroy(vecclone);
    }

    
    if (dir == GHOST_PERMUTATION_ORIG2PERM) {
        vec->traits.flags |= (ghost_densemat_flags_t)GHOST_DENSEMAT_PERMUTED;
    } else {
        vec->traits.flags &= (ghost_densemat_flags_t)(~GHOST_DENSEMAT_PERMUTED);
    }
        

    return GHOST_SUCCESS;


}

template <typename v_t> 
static ghost_error_t FUNCNAME(fromRand_tmpl(ghost_densemat_t *vec))
{
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_INITIALIZATION);

    int needInit = 0;
    FUNCNAME(malloc(vec,&needInit));

#pragma omp parallel
    {
        unsigned int *state;
        ghost_rand_get(&state);
        if( needInit ) {
          DENSEMAT_ITER_INIT(vec,my_rand(state,(v_t *)valptr));
        } else {
          DENSEMAT_ITER(vec,my_rand(state,(v_t *)valptr));
        }
    }

    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_INITIALIZATION);
    return GHOST_SUCCESS;
}

template <typename v_t> 
static ghost_error_t FUNCNAME(fromScalar_tmpl(ghost_densemat_t *vec, void *val))
{
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_INITIALIZATION);

    int needInit = 0;
    FUNCNAME(malloc(vec,&needInit));

    if( needInit ) {
      DENSEMAT_ITER_INIT(vec,*(v_t *)valptr = *(v_t *)val);
    } else {
      DENSEMAT_ITER(vec,*(v_t *)valptr = *(v_t *)val);
    }
    

    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_INITIALIZATION);
    
    return GHOST_SUCCESS;
}


template <typename v_t> 
static ghost_error_t FUNCNAME(string_tmpl(char **str, ghost_densemat_t *vec))
{
    stringstream buffer;
    buffer << std::setprecision(6)
           << std::right
           << std::scientific;

    if (vec->traits.location & GHOST_LOCATION_DEVICE) {
#ifdef GHOST_HAVE_CUDA
        v_t val;
        GHOST_SINGLETHREAD(DENSEMAT_ITER(vec,ghost_cu_download(&val,cuvalptr,vec->elSize);buffer<<val<<(col==vec->traits.ncols-1?"\n":"\t")));
#endif
    } else {
        GHOST_SINGLETHREAD(DENSEMAT_ITER(vec,buffer<<*(v_t *)valptr<<(col==vec->traits.ncols-1?"\n":"\t")));
    }

    GHOST_CALL_RETURN(ghost_malloc((void **)str,buffer.str().length()+1));
    strcpy(*str,buffer.str().c_str());

    return GHOST_SUCCESS;
}

#ifdef GHOST_HAVE_CUDA
inline cublasStatus_t cublasGgeam(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb,
        int m, int n, const float *alpha, const float *A, int lda, const float *beta, const float *B, int ldb, float *C, int ldc) 
{
    return cublasSgeam(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc);
}
inline cublasStatus_t cublasGgeam(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb,
        int m, int n, const ghost_complex<float> *alpha, const ghost_complex<float> *A, int lda, const ghost_complex<float> *beta, const ghost_complex<float> *B, int ldb, ghost_complex<float> *C, int ldc) 
{
    return cublasCgeam(handle,transa,transb,m,n,(const cuComplex *)alpha,(const cuComplex *)A,lda,(const cuComplex *)beta,(const cuComplex *)B,ldb,(cuComplex *)C,ldc);
}
inline cublasStatus_t cublasGgeam(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb,
        int m, int n, const double *alpha, const double *A, int lda, const double *beta, const double *B, int ldb, double *C, int ldc) 
{
    return cublasDgeam(handle,transa,transb,m,n,alpha,A,lda,beta,B,ldb,C,ldc);
}
inline cublasStatus_t cublasGgeam(cublasHandle_t handle, cublasOperation_t transa, cublasOperation_t transb,
        int m, int n, const ghost_complex<double> *alpha, const ghost_complex<double> *A, int lda, const ghost_complex<double> *beta, const ghost_complex<double> *B, int ldb, ghost_complex<double> *C, int ldc) 
{
    return cublasZgeam(handle,transa,transb,m,n,(const cuDoubleComplex *)alpha,(const cuDoubleComplex *)A,lda,(const cuDoubleComplex *)beta,(const cuDoubleComplex *)B,ldb,(cuDoubleComplex *)C,ldc);
}

#endif

template <typename v_t> 
static ghost_error_t FUNCNAME(fromVec_tmpl(ghost_densemat_t *vec, ghost_densemat_t *vec2, ghost_lidx_t roffs, ghost_lidx_t coffs))
{
    GHOST_FUNC_ENTER(GHOST_FUNCTYPE_INITIALIZATION);
    int needInit = 0;
    FUNCNAME(malloc(vec,&needInit));
    if( needInit ) {
        if( vec->traits.ncolspadded != vec->traits.ncols || vec->traits.nrowspadded != vec->traits.nrows || roffs != 0 ) {
            PERFWARNING_LOG("Fast initializing of padded vector block from another vector not implemented, filling with zeros first");
            DENSEMAT_ITER_INIT(vec,memset(valptr,0,sizeof(v_t)));
        }
    }


    
    if (vec2->traits.storage == vec->traits.storage) { 
        if (vec->traits.location & GHOST_LOCATION_DEVICE) {
            if (vec2->traits.location & GHOST_LOCATION_DEVICE) {
                if (DENSEMAT_COMPACT(vec) && DENSEMAT_COMPACT(vec2)) {
                    ghost_cu_memcpy2d(vec->cu_val,vec->stride*vec->elSize,DENSEMAT_CUVALPTR(vec2,roffs,coffs),vec2->stride*vec->elSize,vec->blocklen*vec->elSize,vec->nblock);
                } else {
                    PERFWARNING_LOG("Potentially slow element-wise memcpy!");
                    DENSEMAT_ITER2_OFFS(vec,vec2,roffs,coffs,
                            ghost_cu_memcpy(cuvalptr1,cuvalptr2,vec->elSize));
                }
            } else {
                if (DENSEMAT_COMPACT(vec) && DENSEMAT_COMPACT(vec2)) {
                    ghost_cu_upload2d(vec->cu_val,vec->stride*vec->elSize,DENSEMAT_VALPTR(vec2,roffs,coffs),vec2->stride*vec2->elSize,vec2->blocklen*vec2->elSize,vec2->nblock);
                } else {
                    PERFWARNING_LOG("Potentially slow element-wise upload! (Fast copying not yet implemented)");
                    DENSEMAT_ITER2_OFFS(vec,vec2,roffs,coffs,
                            ghost_cu_upload(cuvalptr1,valptr2,vec->elSize));
                }
            }
        } else {
            if (vec2->traits.location & GHOST_LOCATION_DEVICE) {
                if (DENSEMAT_COMPACT(vec) && DENSEMAT_COMPACT(vec2)) {
                    ghost_cu_download2d(vec->val,vec->stride*vec->elSize,DENSEMAT_CUVALPTR(vec2,roffs,coffs),vec2->stride*vec2->elSize,vec2->blocklen*vec2->elSize,vec2->nblock);
                } else {
                    PERFWARNING_LOG("Potentially slow element-wise download! (Fast copying not yet implemented)");
                    DENSEMAT_ITER2_OFFS(vec,vec2,roffs,coffs,
                            ghost_cu_download(valptr1,cuvalptr2,vec->elSize));
                }
            } else {
                DENSEMAT_ITER2_OFFS(vec,vec2,roffs,coffs,
                        *(v_t *)valptr1 = *(v_t *)valptr2);
            }
        }
    } else {
        INFO_LOG("On-the-fly memtranpose");
        if (vec->traits.location != vec2->traits.location) {
           ERROR_LOG("Inter-device memtranspose not yet implemented!");
           return GHOST_ERR_NOT_IMPLEMENTED;
        }
        if (vec2->traits.flags & GHOST_DENSEMAT_SCATTERED) {
            ERROR_LOG("Not implemented!");
            return GHOST_ERR_NOT_IMPLEMENTED;
        }
           
        if (vec->traits.location & GHOST_LOCATION_DEVICE && 
                vec2->traits.location & GHOST_LOCATION_DEVICE) {
#ifdef GHOST_HAVE_CUDA
            v_t alpha = 1., beta = 0.;
            ghost_lidx_t m,n;
#if defined(COLMAJOR)
            m = vec->traits.nrows;
            n = vec->traits.ncols;
#elif defined(ROWMAJOR)
            m = vec->traits.ncols;
            n = vec->traits.nrows;
#else
#error "Neither ROWMAJOR nor COLMAJOR defined!"
#endif
            cublasHandle_t ghost_cublas_handle;
            GHOST_CALL_RETURN(ghost_cu_cublas_handle(&ghost_cublas_handle));
            CUBLAS_CALL_RETURN(cublasGgeam(ghost_cublas_handle,CUBLAS_OP_T,CUBLAS_OP_T,m,n,&alpha,(const v_t *)vec2->cu_val,vec2->stride,&beta,(v_t *)vec2->cu_val,vec2->stride,(v_t *)vec->cu_val,vec->stride));
#endif
        } else {
            DENSEMAT_ITER2_COMPACT_OFFS_TRANSPOSED(vec,vec2,roffs,coffs,*(v_t *)valptr1 = *(v_t *)valptr2);
        }
    }

    vec->traits.flags |= (ghost_densemat_flags_t)(vec2->traits.flags & GHOST_DENSEMAT_PERMUTED);

    GHOST_FUNC_EXIT(GHOST_FUNCTYPE_INITIALIZATION);
    return GHOST_SUCCESS;
}



extern "C" ghost_error_t FUNCNAME(string_selector(ghost_densemat_t *vec, char **str))
{ 
    ghost_error_t ret = GHOST_SUCCESS;

    SELECT_TMPL_1DATATYPE(vec->traits.datatype,ghost_complex,ret,FUNCNAME(string_tmpl),str,vec);

    return ret;
}

extern "C" ghost_error_t FUNCNAME(normalize_selector(ghost_densemat_t *vec))
{ 
    ghost_error_t ret = GHOST_SUCCESS;

    SELECT_TMPL_1DATATYPE(vec->traits.datatype,ghost_complex,ret,FUNCNAME(normalize_tmpl),vec);

    return ret;
}

extern "C" ghost_error_t FUNCNAME(dotprod_selector(ghost_densemat_t *vec, void *res, ghost_densemat_t *vec2)) 
{
    ghost_error_t ret = GHOST_SUCCESS;

    SELECT_TMPL_1DATATYPE(vec->traits.datatype,ghost_complex,ret,FUNCNAME(dotprod_tmpl),vec,res,vec2);

    return ret;
}

extern "C" ghost_error_t FUNCNAME(norm_selector(ghost_densemat_t *vec, void *res, void *p)) 
{
    ghost_error_t ret = GHOST_SUCCESS;

    SELECT_TMPL_1DATATYPE(vec->traits.datatype,ghost_complex,ret,FUNCNAME(norm_tmpl),vec,res,p);

    return ret;
}

extern "C" ghost_error_t FUNCNAME(vscale_selector(ghost_densemat_t *vec, void *scale)) 
{ 
    ghost_error_t ret = GHOST_SUCCESS;

    SELECT_TMPL_1DATATYPE(vec->traits.datatype,ghost_complex,ret,FUNCNAME(vscale_tmpl),vec,scale);

    return ret;
}

extern "C" ghost_error_t FUNCNAME(vaxpy_selector(ghost_densemat_t *vec, ghost_densemat_t *vec2, void *scale))
{ 
    ghost_error_t ret = GHOST_SUCCESS;

    SELECT_TMPL_1DATATYPE(vec->traits.datatype,ghost_complex,ret,FUNCNAME(vaxpy_tmpl),vec,vec2,scale);

    return ret;
}

extern "C" ghost_error_t FUNCNAME(vaxpby_selector(ghost_densemat_t *vec, ghost_densemat_t *vec2, void *scale, void *b))
{ 
    ghost_error_t ret = GHOST_SUCCESS;

    SELECT_TMPL_1DATATYPE(vec->traits.datatype,ghost_complex,ret,FUNCNAME(vaxpby_tmpl),vec,vec2,scale,b);

    return ret;
}

extern "C" ghost_error_t FUNCNAME(fromRand_selector(ghost_densemat_t *vec))
{ 
    ghost_error_t ret = GHOST_SUCCESS;

    SELECT_TMPL_1DATATYPE(vec->traits.datatype,ghost_complex,ret,FUNCNAME(fromRand_tmpl),vec);

    return ret;
}

extern "C" ghost_error_t FUNCNAME(fromScalar_selector(ghost_densemat_t *vec, void *val))
{ 
    ghost_error_t ret = GHOST_SUCCESS;

    SELECT_TMPL_1DATATYPE(vec->traits.datatype,ghost_complex,ret,FUNCNAME(fromScalar_tmpl),vec,val);

    return ret;
}

extern "C" ghost_error_t FUNCNAME(fromVec_selector(ghost_densemat_t *vec, ghost_densemat_t *vec2, ghost_lidx_t roffs, ghost_lidx_t coffs))
{ 
    ghost_error_t ret = GHOST_SUCCESS;

    SELECT_TMPL_1DATATYPE(vec->traits.datatype,ghost_complex,ret,FUNCNAME(fromVec_tmpl),vec,vec2,roffs,coffs);

    return ret;
}

extern "C" ghost_error_t FUNCNAME(permute_selector(ghost_densemat_t *vec, ghost_permutation_direction_t dir))
{ 
    ghost_error_t ret = GHOST_SUCCESS;

    SELECT_TMPL_1DATATYPE(vec->traits.datatype,ghost_complex,ret,FUNCNAME(permute_tmpl),vec,dir);

    return ret;
}

